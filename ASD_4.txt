#include <iostream>
#include <conio.h>
using namespace std;
/*НАША СТРУКТУРА*/
struct Stack
{
	int *elem = 0;
	int x;                                              //информационный элемент
	Stack *Next, *top;                                   //Голова стека и указатель на следующий элемент
};

/*ФУНКЦИЯ ДОБАВЛЕНИЯ ЭЛЕМЕНТА В СТЕК*/
void pop(Stack *&S);
/*ФУНКЦИЯ ОТОБРАЖЕНИЯ СТЕКА*/
void Show(Stack *S);
/*ФУНКЦИЯ УДАЛЕНИЯ СТЕКА ИЗ ПАМЯТИ*/
void push(Stack *S);


int main()
{
	setlocale(LC_ALL,"ru");
	Stack *S = new Stack;//Выделяем память для стека
	S->top = NULL; //Во избежание ошибок инициализируем первый элемент
	cout << "1 -> добавление элементов в стек\n2 -> вывод на экран\n3 -> удаления стека\n";
	char q;	q = _getch();
	switch (q) {
	case'1':pop(S); break;
	case'2':Show(S); break;
	case'3':push(S); break;
	}
	delete S->top;
	delete S;
	system("pause");
	return 0;
}

/*ФУНКЦИЯ ДОБАВЛЕНИЯ ЭЛЕМЕНТА В СТЕК (в список LIFO)*/
void pop(Stack *&S)                          //Принимаем элемент стека и указатель на стек, при этом говорим, что принимаемый указатель будет сам по себе указателем
{
	cout << "Сколько элементов хотите добавит?\n";
	Stack *pv = new Stack;                              //Выделяем память для нового элемента
	
	while (S->elem == NULL) {
		cin >> pv->x;
		for (int i = 0; i < pv->x; i++) {
			cin >> pv->elem[i];
		}
		pv->Next = S->top; 			                         //Указываем, что следующий элемент это предыдущий
		S->top = pv;                               //Сдвигаем голову на позицию вперед
	}
	}
	

/*ФУНКЦИЯ ОТОБРАЖЕНИЯ СТЕКА*/
void Show(Stack *S)                                 //Нужен только сам стек
{
	Stack *pv = S->top;                          //Объявляем указатель и Указываем ему, что его позиция в голове стека
														//с помощью цикла проходим по всему стеку
	while (pv != NULL)                                //выходим при встрече с пустым полем
	{
		cout << pv->x << " ";                         //Выводим на экран элемент стека
		pv = pv->Next;                              //Переходим к следующему элементу
	}
	cout << endl;
}

/*ФУНКЦИЯ УДАЛЕНИЯ СТЕКА ИЗ ПАМЯТИ*/
void push(Stack *S)
{
	while (S->top != NULL)                        //Пока по адресу не пусто
	{
		Stack *pv = S->top->Next;                    //Временная переменная для хранения адреса следующего элемента
		delete S->top;                                //Освобождаем адрес обозначающий начало
		S->top = pv;                                //Меняем адрес на следующий
	}
}

